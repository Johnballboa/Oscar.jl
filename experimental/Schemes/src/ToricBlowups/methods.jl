@doc raw"""
    total_transform(f::ToricBlowupMorphism, I::MPolyIdeal) -> MPolyIdeal

Let $f\colon Y \to X$ be the toric blowup corresponding to a star subdivision along a ray. Let $R$ and $S$ be the Cox rings of $X$ and $Y$, respectively.
This function returns a homogeneous ideal in $S$ corresponding to the total transform (meaning the scheme-theoretic inverse image) under $f$ of the closed subscheme of $X$ defined by the homogeneous ideal $I$ in $R$.

This is implemented under the following assumptions:
  * the star subdivision adds a ray (instead of subdividing along an existing ray),
  * $X$ is an orbifold (meaning its fan is simplicial), and
  * $X$ has no torus factors (meaning the rays span $N_{\mathbb{R}}$).

# Examples
```jldoctest
julia> X = affine_space(NormalToricVariety, 2)
Normal toric variety

julia> f = blow_up(X, [2, 3])
Toric blowup morphism

julia> R = cox_ring(X)
Multivariate polynomial ring in 2 variables over QQ graded by
  x1 -> 1 by 0 empty matrix
  x2 -> 1 by 0 empty matrix

julia> (x1, x2) = gens(R)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2

julia> I = ideal(R, [x1 + x2])
Ideal generated by
  x1 + x2

julia> total_transform(f, I)
Ideal generated by
  x1*e^2 + x2*e^3
```
"""
function total_transform(f::ToricBlowupMorphism, I::MPolyIdeal)
  return cox_ring_group_homomorphism(f, I)
end

@doc raw"""
    strict_transform(f::ToricBlowupMorphism, I::MPolyIdeal) -> MPolyIdeal

Let $f\colon Y \to X$ be the toric blowup corresponding to a star subdivision along a ray. Let $R$ and $S$ be the Cox rings of $X$ and $Y$, respectively.
Here "strict transform" means the "scheme-theoretic closure of the complement of the exceptional divisor in the scheme-theoretic inverse image".
This function returns a homogeneous ideal in $S$ corresponding to the strict transform under $f$ of the closed subscheme of $X$ defined by the homogeneous ideal $I$ in $R$.

This is implemented under the following assumptions:
  * the star subdivision adds a ray (instead of subdividing along an existing ray),
  * $X$ is an orbifold (meaning its fan is simplicial), and
  * $X$ has no torus factors (meaning the rays span $N_{\mathbb{R}}$).

# Examples
```jldoctest
julia> X = affine_space(NormalToricVariety, 2)
Normal toric variety

julia> f = blow_up(X, [2, 3])
Toric blowup morphism

julia> R = cox_ring(X)
Multivariate polynomial ring in 2 variables over QQ graded by
  x1 -> 1 by 0 empty matrix
  x2 -> 1 by 0 empty matrix

julia> (x1, x2) = gens(R)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2

julia> I = ideal(R, [x1 + x2])
Ideal generated by
  x1 + x2

julia> strict_transform(f, I)
Ideal generated by
  x1 + x2*e
```
"""
function strict_transform(f::ToricBlowupMorphism, I::MPolyIdeal)
  S = cox_ring(domain(f))
  new_var = S[index_of_new_ray(f)]
  J = total_transform(f, I)
  return saturation(J, ideal(S, new_var))
end

@doc raw"""
    strict_transform_with_index(f::ToricBlowupMorphism, I::MPolyIdeal) -> MPolyIdeal

Returns the pair $(J, k)$, where $J$ coincides with `strict_transform(f, I)` and where $k$ is the multiplicity of the total transform along the exceptional prime divisor.

!!! note
    If the multiplicity $k$ is not needed, we recommend to use `strict_transform(f, I)` which is typically faster.

# Examples
```jldoctest
julia> X = affine_space(NormalToricVariety, 2)
Normal toric variety

julia> f = blow_up(X, [2, 3])
Toric blowup morphism

julia> R = cox_ring(X)
Multivariate polynomial ring in 2 variables over QQ graded by
  x1 -> 1 by 0 empty matrix
  x2 -> 1 by 0 empty matrix

julia> (x1, x2) = gens(R)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2

julia> I = ideal(R, [x1 + x2])
Ideal generated by
  x1 + x2

julia> strict_transform_with_index(f, I)
(Ideal (x1 + x2*e), 2)
```
"""
function strict_transform_with_index(f::ToricBlowupMorphism, I::MPolyIdeal)
  S = cox_ring(domain(f))
  new_var = S[index_of_new_ray(f)]
  J = total_transform(f, I)
  return saturation_with_index(J, ideal(new_var))
end

@doc raw"""
    cox_ring_group_homomorphism(f::ToricBlowupMorphism, g::MPolyDecRingElem) -> MPolyDecRingElem
    cox_ring_group_homomorphism(f::ToricBlowupMorphism, I::MPolyIdeal) -> MPolyIdeal

Let $f\colon Y \to X$ be the toric blowup corresponding to a star subdivision along a ray. Let $R$ and $S$ be the Cox rings of $X$ and $Y$, respectively.
Considering $R$ and $S$ with their abelian group structures, there is a group homomorphism $\Phi\colon R \to S$ sending homogeneous ideals to homogeneous ideals with the defining property that the total transform of a subscheme of $X$, given by a homogeneous ideal $I$ in $R$, is the subscheme of $Y$ given by the homogeneous ideal $\Phi(I)$ in $S$.

This is implemented under the following assumptions:
  * the star subdivision adds a ray (instead of subdividing along an existing ray),
  * $X$ is an orbifold (meaning its fan is simplicial), and
  * $X$ has no torus factors (meaning the rays span $N_{\mathbb{R}}$).

# Examples
```jldoctest
julia> X = affine_space(NormalToricVariety, 2)
Normal toric variety

julia> f = blow_up(X, [2, 3])
Toric blowup morphism

julia> R = cox_ring(X)
Multivariate polynomial ring in 2 variables over QQ graded by
  x1 -> 1 by 0 empty matrix
  x2 -> 1 by 0 empty matrix

julia> (x1, x2) = gens(R)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x1
 x2

julia> cox_ring_group_homomorphism(f, x1 + x2)
x1*e^2 + x2*e^3
```
"""
cox_ring_group_homomorphism

function cox_ring_group_homomorphism(f::ToricBlowupMorphism, g::MPolyDecRingElem)
  @req parent(g) === cox_ring(codomain(f)) "g must be an element of the Cox ring of the codomain of f"
  d, phi_exponents = _cox_ring_group_homomorphism_data(f)
  S = cox_ring(domain(f))
  new_var = S[index_of_new_ray(f)]

  # Assuming the i-th variable of `cox_ring(X)` is the i-th variable of `cox_ring(Y)`
  S_vars = elem_type(S)[S[i] for i in 1:nvars(S)]

  make_S_term(c, exps) = c*prod(map(^, S_vars, exps))
  coeff_exps = collect(zip(coefficients(g), exponents(g)))
  h = S(0)
  for (c, exps) in coeff_exps
    new_exp = cdiv(sum(phi_exponents.*exps), d)
    h += new_var^new_exp * make_S_term(c, exps)
  end
  return h
end

function cox_ring_group_homomorphism(f::ToricBlowupMorphism, I::MPolyIdeal)
  S = cox_ring(domain(f))
  return ideal(S, [cox_ring_group_homomorphism(f, g) for g in gens(I)])
end

@attr Tuple{ZZRingElem, Vector{ZZRingElem}} function _cox_ring_group_homomorphism_data(f::ToricBlowupMorphism)
  # f: Y -> X
  X = codomain(f)
  Y = domain(f)
  @req is_normal(X) "Only implemented when the variety is normal"
  @req !has_torusfactor(X) "Only implemented when there are no torus factors"
  @req n_rays(Y) == n_rays(X) + 1 "Only implemented when the blowup adds a ray"
  new_ray = rays(domain(f))[index_of_new_ray(f)]
  c = minimal_supercone(X, new_ray)
  U = affine_normal_toric_variety(c)
  @req is_orbifold(U) "Only implemented when the fan is simplicial"
  d = order(class_group(U))
  A = transpose(matrix(ZZ, rays(c)))
  C = identity_matrix(ZZ, n_rays(c))

  # Making `new_ray` into a singleton SubObjectIterator similar to `rays(c)`
  b_iterator = rays(positive_hull(new_ray))

  # Making `new_ray` into a column vector
  b = transpose(matrix(ZZ, b_iterator))

  # Multiplying by `d` to assure that a solution exists
  b *= d

  vs = solve_mixed(A, b, C)
  n = nvars(cox_ring(X))
  phi_exponents = zeros(ZZ, n)
  for i in 1:n
    ray = _ray_variable_correspondence(X)[cox_ring(X)[i]]
    j = findfirst(isequal(ray), rays(c))
    if isnothing(j)
      phi_exponents[i] = ZZ(0)
    else
      phi_exponents[i] = ZZ(vs[j])
    end
  end
  return d, phi_exponents
end

@doc raw"""
    total_transform(f::AbsSimpleBlowupMorphism, II::IdealSheaf)

Computes the total transform of an ideal sheaf along a blowup.

In particular, this applies in the toric setting. However, note that
currently (October 2023), ideal sheaves are only supported on smooth
toric varieties.

# Examples
```jldoctest
julia> P2 = projective_space(NormalToricVariety, 2)
Normal toric variety

julia> bl = blow_up(P2, [1, 1])
Toric blowup morphism

julia> S = cox_ring(P2);

julia> x, y, z = gens(S);

julia> I = ideal_sheaf(P2, ideal([x*y]))
Sheaf of ideals
  on normal, smooth toric variety
with restrictions
  1: Ideal (x_1_1*x_2_1)
  2: Ideal (x_2_2)
  3: Ideal (x_1_3)

julia> total_transform(bl, I)
Sheaf of ideals
  on normal toric variety
with restrictions
  1: Ideal (x_1_1*x_2_1^2)
  2: Ideal (x_1_2^2*x_2_2)
  3: Ideal (x_2_3)
  4: Ideal (x_1_4)
```
"""
function total_transform(f::AbsSimpleBlowupMorphism, II::AbsIdealSheaf)
  return pullback(f, II)
end

function total_transform(f::AbsBlowupMorphism, II::AbsIdealSheaf)
  return pullback(f, II)
end
